% !TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101

%% ------------------------------------------------------------------------- %%

\chapter{Referencial Teórico}\label{cap:fundamentacao}

\section{Engenharia de Software}
Segundo a definição do \textit{Institute of Electrical and Electronics Engineers} (IEEE) (\citeyear{159342}), a engenharia de \textit{software} é a aplicação de uma sistemática, disciplinada e quantificável abordagem para o desenvolvimento, operação e manutenção de um \textit{software}. Para que a engenharia de \textit{software} seja viável, dada a complexidade dos sistemas demandados na atualidade, foram desenvolvidas etapas, metodologias e ferramentas que dessem suporte aos atores envolvidos no projeto, como desenvolvedores, analistas, investidores, clientes, entre outros.

\subsection{Etapas do Desenvolvimento de Software}
O Ciclo de Vida de Desenvolvimento de Software (SDLC) consiste numa sequência de processos pelos quais o desenvolvimento de um \textit{software} ocorre, de modo a produzir um resultado eficaz e de alta qualidade. Existe alguma variação no número de passos descritos por diferentes fontes, mas, em geral, há sete fases essenciais: planejamento, análise de requisitos, \textit{design}, codificação, testes, implantação e manutenção.

\subsubsection{Planejamento}

A fase inicial envolve definir o propósito e o escopo do \textit{software}. Durante esta etapa, a equipe de desenvolvimento deve levantar as tarefas necessárias, elaborar estratégias para cumpri-las e colaborar de modo a compreender as necessidades dos usuários finais. Neste processo, os objetivos do \textit{software} e qual problema ele se propõe a resolver precisam ficar claros a todos os envolvidos.

Além disso, nesta fase também ocorre o estudo de viabilidade, ou seja, desenvolvedores e outros atores do projeto avaliam desafios técnicos e financeiros que possam impactar a evolução ou o sucesso do \textit{software}. Ao fim desta fase, um plano de projeto é criado, com o intuito de detalhar as funções do sistema, os recursos necessários, possíveis riscos e o cronograma do projeto. Ao definir papéis, responsabilidades e expectativas claras, o planejamento estabelece uma base sólida para um processo eficiente de desenvolvimento.

\subsubsection{Análise de Requisitos}

A segunda fase do SDLC visa identificar e registrar os requisitos dos usuários finais. Nesta etapa, a equipe de projeto realiza o levantamento dos requisitos, por meio da coleta de informações das partes interessadas, como analistas, usuários e clientes. São empregadas técnicas como entrevistas, pesquisas e grupos de foco para compreender as necessidades e expectativas dos usuários.

Após a coleta, os dados são analisados, diferenciando os requisitos essenciais dos desejáveis. Essa análise possibilita a definição das funcionalidades, desempenho, segurança e interfaces do \textit{software}. Neste momento, são definidos os requisitos funcionais e não funcionais. Os requisitos funcionais especificam as funções que o \textit{software} deve realizar, ou seja, o que o sistema deve fazer. Já os requisitos não funcionais tratam de como o sistema deve se comportar, incluindo aspectos como desempenho, segurança, usabilidade e escalabilidade.

O resultado desse processo é o Documento de Especificação de Requisitos (DER), que descreve o propósito, as funcionalidades e características do \textit{software}, servindo como guia para a equipe de desenvolvimento e fornecendo estimativas de custo, quando necessário. O êxito desta fase é crucial para o sucesso do projeto, pois assegura que a solução desenvolvida atenda às expectativas dos usuários.

\subsubsection{Design}

A fase de \textit{design} é responsável pela definição da estrutura do \textit{software}, abrangendo sua funcionalidade e aparência. A equipe de desenvolvimento detalha a arquitetura do sistema, a navegação, as interfaces de usuário e a modelagem do banco de dados, assegurando que o \textit{software} tenha boa usabilidade e seja eficiente.

Entre as atividades desta fase, destaca-se a elaboração de diagramas de fluxo de dados, de entidade-relacionamento, de classes, protótipos de interface e diagramas arquiteturais. O objetivo é garantir que as estruturas projetadas sejam suficientes para dar suporte a todas as funcionalidades do sistema. Também são identificadas dependências, pontos de integração e eventuais restrições, como limitações do equipamento físico e requisitos de desempenho.

O resultado desta fase é o Documento de \textit{Design} de Software (DDS) que estrutura formalmente as informações do projeto e trata preocupações de \textit{design}. Neste documento, são adicionados os artefatos produzidos, servindo como guia estável para coordenar equipes grandes e garantir que todos os componentes do sistema funcionem de maneira integrada.

\subsubsection{Codificação}

Na fase de codificação, os engenheiros e desenvolvedores transformam o \textit{design} do \textit{software} em código executável. O objetivo é produzir um \textit{software} funcional, eficiente e com boa usabilidade. Para isso, utilizam-se linguagens de programação adequadas, seguindo o DDS e diretrizes de codificação estabelecidas pela organização e pela legislação local.

Durante esta fase, são realizadas revisões de código, nas quais os membros da equipe examinam o trabalho uns dos outros para identificar erros ou inconsistências, garantindo elevados padrões de qualidade. Além disso, testes preliminares internos são conduzidos para garantir que as funcionalidades básicas do sistema foram atendidas.

Ao final da fase de codificação, o \textit{software} passa a existir como um produto funcional, representando a materialização dos esforços das etapas anteriores, mesmo que ainda sejam necessários refinamentos e ajustes subsequentes. O resultado desta fase é o código-fonte.

\subsubsection{Testes}

A fase de testes consiste em verificar a qualidade e a confiabilidade do \textit{software} antes de sua entrega aos usuários finais. Seu objetivo é identificar falhas, erros e vulnerabilidades, assegurando que o sistema atenda aos requisitos especificados.

Inicialmente, são definidos parâmetros de teste alinhados aos requisitos do \textit{software} e casos de teste que contemplem diferentes cenários de uso. Em seguida, são conduzidos testes de diversos níveis e tipos, incluindo testes de unidade, de integração, de sistema, de segurança e de aceitação, permitindo a avaliação tanto de componentes individuais quanto da operação do sistema na sua totalidade.

Quando um erro é identificado, ele é registrado detalhadamente, incluindo seu comportamento, métodos de reprodução e impacto sobre o sistema. As falhas são encaminhadas para correção e o \textit{software} retorna à fase de testes para validação. Este ciclo de teste e correção se repete até que o sistema esteja conforme os critérios previamente estabelecidos. O resultado desta fase é um código-fonte mais robusto e menos propenso a falhas.

\subsubsection{Implantação}

A fase de implantação ou \textit{deployment} consiste em disponibilizar o \textit{software} aos usuários finais, garantindo sua operacionalidade no ambiente de produção. Este processo ocorre tanto no primeiro lançamento do sistema, quanto quando ele já está em uso pelos usuários e passando por atualizações. Por isso, o processo deve minimizar interrupções e impactos negativos nos acessos dos usuários.

A escolha da estratégia de implantação é feita conforme as características do sistema e de seus usuários. As estratégias mais comuns são:

\begin{itemize}
    \item \textit{Rolling}: a atualização ocorre de forma gradual, substituindo instâncias antigas por novas até que todo o sistema esteja atualizado;
    \item \textit{Blue-Green}: dois ambientes paralelos são mantidos, um em produção e outro em preparação, permitindo a troca imediata entre eles;
    \item \textit{Canary}: a nova versão é liberada primeiramente para um grupo de usuários, monitorando o comportamento do sistema antes de expandir a implantação para todos.
\end{itemize}

Além de colocar o \textit{software} em operação, esta fase envolve assegurar que os usuários compreendam seu funcionamento. Para isso, podem ser fornecidos manuais, treinamentos e suporte técnico. Desta maneira, a fase de implantação marca a transição do \textit{software} de projeto para produto, iniciando efetivamente o cumprimento de seus objetivos e a entrega de valor ao usuário.

\subsubsection{Manutenção}

A fase de manutenção é caracterizada por suporte contínuo e por melhorias incrementais, de modo a garantir que o \textit{software} mantenha seu funcionamento adequado, acompanhe as necessidades dos usuários e as demandas de mercado. Nesta fase, são realizadas atualizações, correções de falhas e suporte ao usuário.

Considerando o horizonte de longo prazo, a manutenção inclui estratégias de modernização ou substituição do \textit{software}, buscando manter sua relevância e adequação às evoluções tecnológicas.

\subsection{Metodologias de Desenvolvimento}

As metodologias de desenvolvimento de \textit{software} consistem em abordagens sistemáticas para organizar, planejar e executar projetos de engenharia de \textit{software}. Cada metodologia apresenta vantagens e limitações, sendo a escolha dependente do tamanho do projeto, grau de complexidade, maturidade da equipe e expectativa de mudanças nos requisitos.

\subsubsection{Método de Cascata}

A metodologia cascata é uma abordagem sequencial em que cada fase do desenvolvimento de \textit{software} deve ser concluída antes de iniciar a seguinte. Ela é adequada para projetos com requisitos muito definidos e pouca probabilidade de mudanças durante o desenvolvimento. O modelo enfatiza documentação detalhada e planejamento prévio, garantindo controle rígido sobre prazos e entregas. Embora simples de aplicar, pode se mostrar inflexível diante de alterações nos requisitos ou no ambiente de negócios.

\subsubsection{Metodologias Ágeis}

As metodologias ágeis consistem em práticas iterativas e incrementais, voltadas à entrega contínua de valor ao usuário e à adaptação rápida às mudanças nos requisitos. As abordagens ágeis valorizam colaboração, flexibilidade e melhoria contínua, sendo especialmente adequada para projetos dinâmicos e de alta complexidade. 

Além disso, elas são geralmente complementadas por práticas de Integração Contínua e Entrega Contínua (CI/CD), que automatizam a construção, teste e implantação do \textit{software}. Desta maneira, a utilização de CI/CD permite que novas funcionalidades e correções sejam disponibilizadas rapidamente, mantendo a qualidade do sistema e reduzindo o tempo de reposta entre a equipe de desenvolvimento e os usuários.

Alguns exemplos de métodos ágeis incluem:
\begin{itemize}
    \item \textbf{Extreme Programming (XP)}: enfatiza práticas de programação colaborativa, como \textit{pair programming}, integração contínua, testes automatizados e feedback constante do cliente.
    \item \textbf{Lean Software Development}: baseado nos princípios de eliminação de desperdício, entrega rápida e melhoria contínua, priorizando valor para o cliente.
\end{itemize}



\begin{itemize}
    \item \textit{Scrum}: método iterativo que organiza o trabalho em ciclos curtos, denominados \textit{sprints} (iterações), com duração de uma a quatro semanas. Define papéis específicos, como o responsável pelo produto (\textit{product owner}), o facilitador do processo (\textit{scrum master}) e a equipe de desenvolvimento. Inclui ainda reuniões regulares, como o planejamento da iteração (\textit{sprint planning}), reuniões diárias de acompanhamento (\textit{daily}), a revisão da iteração e a retrospectiva, que garantem planejamento, monitoramento e melhoria contínua do processo.
    
    \item \textit{Kanban}: método visual de gestão do fluxo de trabalho, baseado na utilização de quadros divididos em colunas que representam etapas do processo (por exemplo, ``A Fazer'', ``Em Progresso'' e ``Concluído''). Cada atividade é representada por um cartão que se movimenta conforme avança nas etapas, promovendo transparência, fluxo contínuo e foco na identificação e eliminação de gargalos.
    
    \item Programação extrema (\textit{extreme programming} — XP): metodologia ágil que enfatiza práticas de desenvolvimento colaborativo e de qualidade, como programação em par, integração contínua, desenvolvimento orientado a testes e refatoração frequente. Valoriza o envolvimento próximo do cliente, a simplicidade do código e a adaptação rápida às mudanças de requisitos.
    
    \item Desenvolvimento enxuto (\textit{lean software development}): abordagem inspirada nos princípios da produção enxuta, que busca eliminar desperdícios, reduzir custos e acelerar entregas. Essa metodologia prioriza a criação de valor para o cliente, a melhoria contínua e a capacitação das equipes para tomadas de decisão mais eficientes.
\end{itemize}

\subsection{Ferramentas de Desenvolvimento}

As ferramentas de desenvolvimento de software oferecem suporte às etapas do ciclo de vida, desde planejamento até manutenção. Elas incluem:

\begin{itemize}
    \item \textbf{Sistemas de Controle de Versão} (como Git e SVN): permitem gerenciar alterações no código-fonte, possibilitando colaboração entre desenvolvedores e rastreamento de histórico.
    \item \textbf{Ambientes de Desenvolvimento Integrados (IDEs)} (como Visual Studio, IntelliJ IDEA e Eclipse): fornecem recursos como edição de código, depuração, testes e integração com sistemas de controle de versão.
    \item \textbf{Ferramentas de Gerenciamento de Projeto} (como Jira, Trello e Asana): auxiliam na organização de tarefas, acompanhamento de progresso e comunicação entre equipes.
    \item \textbf{Ferramentas de Integração e Entrega Contínua (CI/CD)} (como Jenkins, GitHub Actions e GitLab CI): automatizam testes, builds e implantações, promovendo qualidade e agilidade.
    \item \textbf{Ferramentas de Teste} (como Selenium, JUnit e Postman): permitem a realização de testes automatizados e manuais para validar funcionalidades, desempenho e segurança do software.
\end{itemize}

O uso combinado dessas ferramentas contribui para maior produtividade, qualidade e confiabilidade no desenvolvimento de software.

\section{Inteligência Artificial}
\subsection{Conceitos Básicos}

Inteligência Artificial (IA) é o campo da ciência da computação que se dedica a criar sistemas capazes de executar tarefas que normalmente exigem inteligência humana, como reconhecimento de padrões, tomada de decisão e aprendizado a partir de dados. A IA pode ser classificada em:

\begin{itemize}
    \item \textbf{IA Fraca (Narrow AI)}: sistemas projetados para executar tarefas específicas, sem consciência ou compreensão geral do mundo.
    \item \textbf{IA Forte (General AI)}: hipotéticos sistemas capazes de realizar qualquer tarefa cognitiva que um humano consegue executar.
    \item \textbf{IA Baseada em Aprendizado de Máquina}: sistemas que melhoram seu desempenho por meio da análise de grandes volumes de dados e ajuste de parâmetros internos.
\end{itemize}

\subsection{Redes Neurais}

Redes neurais artificiais são modelos computacionais inspirados na estrutura do cérebro humano. Elas são compostas por camadas de nós (neurônios artificiais) interconectados, capazes de processar informações e aprender padrões a partir de exemplos. Redes neurais são amplamente utilizadas em tarefas como classificação, reconhecimento de imagens e processamento de linguagem natural.

\subsection{Aprendizado de Máquina}

Aprendizado de Máquina (Machine Learning) é um subcampo da IA que se concentra em criar algoritmos capazes de aprender e fazer previsões a partir de dados, sem serem explicitamente programados para cada tarefa. Os principais tipos de aprendizado incluem:

\begin{itemize}
    \item \textbf{Supervisionado}: o algoritmo aprende a partir de exemplos rotulados, tentando prever saídas corretas para novas entradas.
    \item \textbf{Não Supervisionado}: o algoritmo identifica padrões ou estruturas em dados não rotulados.
    \item \textbf{Por Reforço}: o algoritmo aprende tomando ações em um ambiente e recebendo recompensas ou penalidades, buscando maximizar o desempenho ao longo do tempo.
\end{itemize}

\section{IA Generativa}
\subsection{Modelos de Linguagem}

Modelos de linguagem são algoritmos capazes de compreender, gerar e manipular texto em linguagem natural. Eles aprendem padrões estatísticos e semânticos a partir de grandes corpora de texto e são a base para sistemas de tradução automática, assistentes virtuais e chatbots avançados.

\subsection{Transformers}

Transformers são uma arquitetura de redes neurais introduzida em 2017, projetada para lidar eficientemente com sequências de dados, como texto. Utilizam mecanismos de atenção que permitem processar relações entre palavras de forma paralela, superando limitações de modelos recorrentes tradicionais.

\subsection{LLMs (\textit{Large Language Models})}

Large Language Models (LLMs) são modelos de linguagem treinados com enormes volumes de dados textuais, contendo bilhões de parâmetros. Eles são capazes de gerar texto coerente, resumir informações, responder perguntas e realizar tarefas complexas de processamento de linguagem natural. Exemplos incluem GPT, BERT e T5.
